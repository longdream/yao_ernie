#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

use anyhow::Result;
use reqwest::Client;
use serde::{Deserialize, Serialize};
use std::io::Write as _;
use tauri::Manager;
use tauri::Window;
use tauri::Emitter;
use tauri::{menu::{Menu, MenuItem}, tray::TrayIconBuilder};
use tauri_plugin_global_shortcut::GlobalShortcutExt;
use enigo::{Enigo, Key, Keyboard, Settings};
use std::sync::{Arc, Mutex};
use xcap::Monitor;
use base64::{Engine as _, engine::general_purpose};
use image::ImageFormat;

// å…¨å±€å…‰æ ‡ä½ç½®å­˜å‚¨
static CURSOR_POSITION: std::sync::OnceLock<Arc<Mutex<Option<(i32, i32)>>>> = std::sync::OnceLock::new();


// å…¨å±€åº”ç”¨å¥æŸ„å­˜å‚¨
static APP_HANDLE: std::sync::OnceLock<Arc<Mutex<Option<tauri::AppHandle>>>> = std::sync::OnceLock::new();

#[cfg(target_os = "windows")]
use windows::Win32::UI::WindowsAndMessaging::{GetCursorPos, SetWindowsHookExW, CallNextHookEx, WH_MOUSE_LL, WM_LBUTTONDOWN, GetSystemMetrics, SM_CXSCREEN, SM_CYSCREEN};
#[cfg(target_os = "windows")]
use windows::Win32::Foundation::{POINT, WPARAM, LPARAM, LRESULT, HINSTANCE};
#[cfg(target_os = "windows")]
use windows::Win32::UI::Input::KeyboardAndMouse::{VK_CONTROL, GetAsyncKeyState};
#[cfg(target_os = "windows")]
use windows::Win32::System::LibraryLoader::GetModuleHandleW;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ModelConfig {
  pub name: String,
  pub provider: String,
  pub base_url: String,
  pub api_key: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AppConfig {
  pub provider: String,
  pub base_url: String,
  pub api_key: Option<String>,
  pub model: Option<String>,
  #[serde(default)]
  pub models: Option<Vec<ModelConfig>>,
  #[serde(default)]
  pub streaming_enabled: Option<bool>,
  #[serde(default)]
  pub default_think: Option<bool>,
  #[serde(default)]
  pub max_context_messages: Option<u32>,
  #[serde(default)]
  pub temperature: Option<f64>,
}

#[tauri::command]
async fn proxy_models(config: AppConfig) -> Result<String, String> {
  let client = Client::new();
  let url = format!("{}/v1/models", config.base_url.trim_end_matches('/'));
  let mut req = client.get(url);
  if let Some(k) = config.api_key {
    req = req.bearer_auth(k);
  }
  let resp = req.send().await.map_err(|e| e.to_string())?;
  let v: serde_json::Value = resp.json().await.map_err(|e| e.to_string())?;
  let list = v.get("data").and_then(|m| m.as_array()).map(|arr| {
    arr.iter()
      .filter_map(|m| m.get("id").and_then(|n| n.as_str()).map(|s| s.to_string()))
      .collect::<Vec<String>>()
  }).unwrap_or_default();
  let result = serde_json::to_string(&list).map_err(|e| e.to_string())?;
  Ok(result)
}

#[tauri::command]
async fn proxy_chat_stream(body: String) -> Result<String, String> {
  // Return the body handle string back for processing
  Ok(body)
}

#[tauri::command]
async fn proxy_chat(handle: String) -> Result<String, String> {
  #[derive(Deserialize)]
  struct InBody { config: AppConfig, messages: Vec<Message>, model: String, #[serde(default)] think: bool }
  let parsed: InBody = serde_json::from_str(&handle).map_err(|e| e.to_string())?;
  chat_once(parsed.config, parsed.messages, parsed.model, parsed.think).await.map_err(|e| e.to_string())
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct Message { 
  role: String, 
  content: String,
  #[serde(default)]
  images: Option<Vec<ImageAttachment>>
}

#[derive(Debug, Clone, Serialize, Deserialize)]
struct ImageAttachment {
  id: String,
  name: String,
  url: String,
  base64: String,
  #[serde(rename = "mimeType")]
  mime_type: String,
  size: u64,
}

async fn chat_once(config: AppConfig, messages: Vec<Message>, model: String, _think: bool) -> Result<String> {
  eprintln!("[DEBUG] chat_once called with config: provider={}, baseUrl={}, apiKey={:?}", 
    config.provider, config.base_url, config.api_key.as_ref().map(|k| format!("{}...", &k[..std::cmp::min(8, k.len())])));
  
  let client = Client::new();
  let url = format!("{}/chat/completions", config.base_url.trim_end_matches('/'));
  eprintln!("[DEBUG] OpenAI API URL: {}", url);
  
  // è½¬æ¢æ¶ˆæ¯æ ¼å¼ä»¥æ”¯æŒå›¾ç‰‡
  let api_messages: Vec<serde_json::Value> = messages.iter().map(|msg| {
    if let Some(images) = &msg.images {
      if !images.is_empty() {
        // æœ‰å›¾ç‰‡çš„æ¶ˆæ¯ï¼Œä½¿ç”¨Vision APIæ ¼å¼
        let mut content_parts = vec![
          serde_json::json!({
            "type": "text",
            "text": msg.content
          })
        ];
        
        // æ·»åŠ å›¾ç‰‡å†…å®¹
        for image in images {
          content_parts.push(serde_json::json!({
            "type": "image_url",
            "image_url": {
              "url": format!("data:{};base64,{}", image.mime_type, image.base64)
            }
          }));
        }
        
        serde_json::json!({
          "role": msg.role,
          "content": content_parts
        })
      } else {
        // æ— å›¾ç‰‡ï¼Œä½¿ç”¨æ™®é€šæ ¼å¼
        serde_json::json!({
          "role": msg.role,
          "content": msg.content
        })
      }
    } else {
      // æ— å›¾ç‰‡ï¼Œä½¿ç”¨æ™®é€šæ ¼å¼
      serde_json::json!({
        "role": msg.role,
        "content": msg.content
      })
    }
  }).collect();
  
  let body = serde_json::json!({
    "model": model,
    "messages": api_messages,
    "stream": false,
    "temperature": config.temperature.unwrap_or(0.6)
  });
  eprintln!("[DEBUG] Request body: {}", serde_json::to_string_pretty(&body).unwrap_or_default());
  let mut req = client.post(url)
    .header("Content-Type", "application/json")
    .header("User-Agent", "Yao/1.0")
    .json(&body);
  if let Some(k) = &config.api_key {
    if !k.is_empty() {
      eprintln!("[DEBUG] Using API key: {}...", &k[..std::cmp::min(8, k.len())]);
      req = req.bearer_auth(k);
    } else {
      eprintln!("[DEBUG] API key is empty");
    }
  } else {
    eprintln!("[DEBUG] No API key provided");
  }
  let resp = req.send().await?;
  let status = resp.status();
  let text = resp.text().await?;
  eprintln!("[DEBUG] Response status: {}", status);
  eprintln!("[DEBUG] Response body: {}", text);
  if let Ok(v) = serde_json::from_str::<serde_json::Value>(&text) {
    if let Some(content) = v
      .get("choices")
      .and_then(|c| c.get(0))
      .and_then(|c| c.get("message"))
      .and_then(|m| m.get("content"))
      .and_then(|c| c.as_str())
    {
      return Ok(content.to_string());
    }
    if !status.is_success() {
      let err = v.get("error").and_then(|e| e.get("message")).and_then(|m| m.as_str()).unwrap_or(text.as_str());
      anyhow::bail!(err.to_string());
    }
  }
  anyhow::bail!(format!("openai empty response: status={} body={}", status, text))
}

#[tauri::command]
async fn get_log_path(_app: tauri::AppHandle) -> Result<String, String> {
  // Prefer executable directory /logs/app.log
  if let Ok(exe) = std::env::current_exe() {
    if let Some(dir) = exe.parent() {
      let p = dir.join("logs").join("app.log");
      return Ok(p.to_string_lossy().into_owned());
    }
  }
  // Fallback to app data dir
  let base = _app.path().app_local_data_dir().map_err(|e| e.to_string())?;
  let p = base.join("logs").join("app.log");
  Ok(p.to_string_lossy().into_owned())
}

#[tauri::command]
async fn get_conversations_path(_app: tauri::AppHandle) -> Result<String, String> {
  if let Ok(exe) = std::env::current_exe() {
    if let Some(dir) = exe.parent() {
      let p = dir.join("conversations.json");
      return Ok(p.to_string_lossy().into_owned());
    }
  }
  let base = _app.path().app_local_data_dir().map_err(|e| e.to_string())?;
  let p = base.join("conversations.json");
  Ok(p.to_string_lossy().into_owned())
}

#[tauri::command]
async fn write_log_line(_app: tauri::AppHandle, line: String) -> Result<(), String> {
  // Use exe dir logs
  let base = std::env::current_exe().map_err(|e| e.to_string())?;
  let dir = base.parent().ok_or("no parent")?.join("logs");
  std::fs::create_dir_all(&dir).map_err(|e| e.to_string())?;
  let file = dir.join("app.log");
  let mut f = std::fs::OpenOptions::new()
    .create(true)
    .append(true)
    .open(file)
    .map_err(|e| e.to_string())?;
  writeln!(f, "{}", line).map_err(|e| e.to_string())?;
  Ok(())
}

#[tauri::command]
async fn get_config_path(_app: tauri::AppHandle) -> Result<String, String> {
  // Always use app data directory for safety and permission compliance
  let base = _app.path().app_local_data_dir().map_err(|e| e.to_string())?;
  
  // Ensure directory exists
  if let Err(e) = std::fs::create_dir_all(&base) {
    eprintln!("Failed to create config directory: {}", e);
  }
  
  let p = base.join("settings.json");
  Ok(p.to_string_lossy().into_owned())
}

#[tauri::command]
async fn start_chat_stream(window: Window, body: String) -> Result<String, String> {
  #[derive(Deserialize)]
  struct InBody { config: AppConfig, messages: Vec<Message>, model: String, #[serde(default)] think: bool }
  let parsed: InBody = serde_json::from_str(&body).map_err(|e| e.to_string())?;
  // simple unique id without external deps
  let millis = std::time::SystemTime::now()
    .duration_since(std::time::UNIX_EPOCH)
    .unwrap_or_else(|_| std::time::Duration::from_millis(0))
    .as_millis();
  let stream_id = format!("stream-{}", millis);
  let sid = stream_id.clone();

  // log start
  if let Ok(_path) = get_log_path(window.app_handle().clone()).await {
    let _ = write_log_line(window.app_handle().clone(), format!(
      "[chat-start] id={} model={} think={} input={}",
      stream_id,
      parsed.model,
      parsed.think,
      parsed
        .messages
        .iter()
        .rev()
        .find(|m| m.role == "user")
        .map(|m| m.content.as_str())
        .unwrap_or("")
    ))
    .await;
  }

  // spawn task
  let win = window.clone();
  tauri::async_runtime::spawn(async move {
    match chat_once(parsed.config, parsed.messages.clone(), parsed.model.clone(), parsed.think).await {
      Ok(content) => {
        // emit chunks by characters batches of 8 for smoother UI
        let mut buf = String::new();
        for (i, ch) in content.chars().enumerate() {
          buf.push(ch);
          if buf.len() >= 8 || i == content.chars().count().saturating_sub(1) {
            let _ = win.emit(&format!("chat-chunk:{}", sid), buf.clone());
            buf.clear();
          }
        }
        let _ = win.emit(&format!("chat-end:{}", sid), "");
        let _ = write_log_line(win.app_handle().clone(), format!(
          "[chat-end] id={} output_len={}",
          sid,
          content.len()
        ))
        .await;
      }
      Err(err) => {
        let _ = win.emit(&format!("chat-error:{}", sid), err.to_string());
        let _ = write_log_line(win.app_handle().clone(), format!(
          "[chat-error] id={} err={}",
          sid,
          err.to_string()
        ))
        .await;
      }
    }
  });

  Ok(stream_id)
}

// æ³¨é‡Šæ‰æœªä½¿ç”¨çš„get_cursor_positionå‡½æ•°
// #[cfg(target_os = "windows")]
// fn get_cursor_position() -> Result<(i32, i32), String> {
//   unsafe {
//     let mut point = POINT { x: 0, y: 0 };
//     if GetCursorPos(&mut point).is_ok() {
//       Ok((point.x, point.y))
//     } else {
//       Err("Failed to get cursor position".to_string())
//     }
//   }
// }

// #[cfg(not(target_os = "windows"))]
// fn get_cursor_position() -> Result<(i32, i32), String> {
//   Err("Cursor position detection not supported on this platform".to_string())
// }

// è®¾ç½®é¼ æ ‡å…‰æ ‡ä½ç½®
#[cfg(target_os = "windows")]
fn set_cursor_position(x: i32, y: i32) -> Result<(), String> {
  use windows::Win32::UI::WindowsAndMessaging::SetCursorPos;
  unsafe {
    if SetCursorPos(x, y).is_ok() {
      Ok(())
    } else {
      Err("Failed to set cursor position".to_string())
    }
  }
}

#[cfg(not(target_os = "windows"))]
fn set_cursor_position(_x: i32, _y: i32) -> Result<(), String> {
  Err("Cursor position setting not supported on this platform".to_string())
}

// åœ¨æŒ‡å®šä½ç½®ç‚¹å‡»é¼ æ ‡
#[cfg(target_os = "windows")]
fn click_at_position(x: i32, y: i32) -> Result<(), String> {
  use windows::Win32::UI::WindowsAndMessaging::SetCursorPos;
  use windows::Win32::UI::Input::KeyboardAndMouse::{SendInput, INPUT, INPUT_MOUSE, MOUSEINPUT};
  use windows::Win32::UI::Input::KeyboardAndMouse::{MOUSEEVENTF_LEFTDOWN, MOUSEEVENTF_LEFTUP};
  
  unsafe {
    // è®¾ç½®å…‰æ ‡ä½ç½®
    SetCursorPos(x, y).map_err(|e| format!("Failed to set cursor position: {}", e))?;
    
    // åˆ›å»ºé¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
    let input_down = INPUT {
      r#type: INPUT_MOUSE,
      Anonymous: windows::Win32::UI::Input::KeyboardAndMouse::INPUT_0 {
        mi: MOUSEINPUT {
          dx: 0,
          dy: 0,
          mouseData: 0,
          dwFlags: MOUSEEVENTF_LEFTDOWN,
          time: 0,
          dwExtraInfo: 0,
        },
      },
    };
    
    // åˆ›å»ºé¼ æ ‡é‡Šæ”¾äº‹ä»¶
    let input_up = INPUT {
      r#type: INPUT_MOUSE,
      Anonymous: windows::Win32::UI::Input::KeyboardAndMouse::INPUT_0 {
        mi: MOUSEINPUT {
          dx: 0,
          dy: 0,
          mouseData: 0,
          dwFlags: MOUSEEVENTF_LEFTUP,
          time: 0,
          dwExtraInfo: 0,
        },
      },
    };
    
    // å‘é€æŒ‰ä¸‹äº‹ä»¶
    SendInput(&[input_down], std::mem::size_of::<INPUT>() as i32);
    // çŸ­æš‚å»¶è¿Ÿ
    std::thread::sleep(std::time::Duration::from_millis(10));
    // å‘é€é‡Šæ”¾äº‹ä»¶
    SendInput(&[input_up], std::mem::size_of::<INPUT>() as i32);
    
    Ok(())
  }
}

#[cfg(not(target_os = "windows"))]
fn click_at_position(_x: i32, _y: i32) -> Result<(), String> {
  Err("Mouse clicking not supported on this platform".to_string())
}

// Windowsé¼ æ ‡é’©å­å›è°ƒå‡½æ•°
#[cfg(target_os = "windows")]
unsafe extern "system" fn mouse_hook_proc(n_code: i32, w_param: WPARAM, l_param: LPARAM) -> LRESULT {
  if n_code >= 0 {
    // è·å–å½“å‰é¼ æ ‡ä½ç½®
    let mut cursor_pos = POINT { x: 0, y: 0 };
    let _ = GetCursorPos(&mut cursor_pos);
    let current_pos = (cursor_pos.x, cursor_pos.y);
    
    // æ£€æŸ¥ä¿®é¥°é”®çŠ¶æ€
    let ctrl_pressed = GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000 != 0;
    
    match w_param.0 as u32 {
      // å·¦é”®æŒ‰ä¸‹ - æ£€æŸ¥ä¿®é¥°é”®
      WM_LBUTTONDOWN => {
        // Ctrl+å·¦é”® - å¿«é€Ÿè¾“å…¥
        if ctrl_pressed {
          println!("ğŸ¯ Ctrl+Left Click detected!");
          
          println!("ğŸ“ Mouse position: ({}, {})", current_pos.0, current_pos.1);
          
          // å­˜å‚¨å…‰æ ‡ä½ç½®
          let cursor_pos_storage = CURSOR_POSITION.get_or_init(|| Arc::new(Mutex::new(None)));
          if let Ok(mut pos) = cursor_pos_storage.lock() {
            *pos = Some(current_pos);
          }
          
          // è·å–åº”ç”¨å¥æŸ„å¹¶æ˜¾ç¤ºå¿«é€Ÿè¾“å…¥çª—å£
          if let Some(app_handle_storage) = APP_HANDLE.get() {
            if let Ok(app_handle_opt) = app_handle_storage.lock() {
              if let Some(app_handle) = app_handle_opt.as_ref() {
                let app_clone = app_handle.clone();
                tauri::async_runtime::spawn(async move {
                  println!("ğŸ“ Starting to show quick input window from mouse hook...");
                  if let Err(e) = show_quick_input_window(app_clone).await {
                    eprintln!("âŒ Failed to show quick input window: {}", e);
                  } else {
                    println!("âœ… Quick input window command completed successfully");
                  }
                });
              }
            }
          }
          
          // é˜»æ­¢é»˜è®¤çš„é¼ æ ‡ç‚¹å‡»è¡Œä¸ºï¼Œé˜²æ­¢è¯¯æ“ä½œ
          return LRESULT(1);
        }
      }
      
      _ => {}
    }
  }
  
  CallNextHookEx(None, n_code, w_param, l_param)
}

// è®¾ç½®å…¨å±€é¼ æ ‡é’©å­
#[cfg(target_os = "windows")]
fn setup_mouse_hook() -> Result<(), String> {
  unsafe {
    let h_instance = GetModuleHandleW(None).map_err(|e| format!("Failed to get module handle: {}", e))?;
    let hook = SetWindowsHookExW(
      WH_MOUSE_LL,
      Some(mouse_hook_proc),
      HINSTANCE(h_instance.0),
      0
    ).map_err(|e| format!("Failed to set mouse hook: {}", e))?;
    
    if hook.is_invalid() {
      return Err("Failed to install mouse hook".to_string());
    }
    
    println!("âœ… Global mouse hook installed successfully");
    Ok(())
  }
}

#[cfg(not(target_os = "windows"))]
fn setup_mouse_hook() -> Result<(), String> {
  Err("Mouse hook not supported on this platform".to_string())
}

// è®¡ç®—æ™ºèƒ½çª—å£ä½ç½®
#[cfg(target_os = "windows")]
fn calculate_smart_position(mouse_x: i32, mouse_y: i32, window_width: i32, window_height: i32) -> Result<(i32, i32), String> {
  unsafe {
    let screen_width = GetSystemMetrics(SM_CXSCREEN);
    let screen_height = GetSystemMetrics(SM_CYSCREEN);
    
    println!("ğŸ“ Screen size: {}x{}, Mouse: ({}, {}), Window: {}x{}", 
             screen_width, screen_height, mouse_x, mouse_y, window_width, window_height);
    
    let margin = 20; // è¾¹è·
    let mut x = mouse_x + margin; // é»˜è®¤æ˜¾ç¤ºåœ¨é¼ æ ‡å³è¾¹
    let mut y = mouse_y - (window_height / 2); // å‚ç›´å±…ä¸­
    
    // æ£€æŸ¥å³è¾¹ç•Œï¼Œå¦‚æœè¶…å‡ºåˆ™æ˜¾ç¤ºåœ¨å·¦è¾¹
    if x + window_width > screen_width - margin {
      x = mouse_x - window_width - margin;
      println!("ğŸ”„ Adjusted to left side due to right boundary");
    }
    
    // æ£€æŸ¥å·¦è¾¹ç•Œ
    if x < margin {
      x = margin;
      println!("ğŸ”„ Adjusted to margin due to left boundary");
    }
    
    // æ£€æŸ¥ä¸‹è¾¹ç•Œï¼Œå¦‚æœè¶…å‡ºåˆ™æ˜¾ç¤ºåœ¨ä¸Šé¢
    if y + window_height > screen_height - margin {
      y = mouse_y - window_height - margin;
      println!("ğŸ”„ Adjusted to top due to bottom boundary");
    }
    
    // æ£€æŸ¥ä¸Šè¾¹ç•Œ
    if y < margin {
      y = margin;
      println!("ğŸ”„ Adjusted to margin due to top boundary");
    }
    
    println!("âœ… Final position: ({}, {})", x, y);
    Ok((x, y))
  }
}

#[cfg(not(target_os = "windows"))]
fn calculate_smart_position(mouse_x: i32, mouse_y: i32, window_width: i32, window_height: i32) -> Result<(i32, i32), String> {
  // éWindowså¹³å°çš„ç®€å•å®ç°
  let margin = 20;
  let x = mouse_x + margin;
  let y = mouse_y - (window_height / 2);
  Ok((x, y))
}

// æ–°çš„æˆªå›¾åŠŸèƒ½
#[tauri::command]
async fn start_screenshot() -> Result<(), String> {
  println!("ğŸ–¼ï¸ Starting system screenshot...");
  
  // è·å–åº”ç”¨å¥æŸ„
  if let Some(app_handle_storage) = APP_HANDLE.get() {
    if let Ok(app_handle_opt) = app_handle_storage.lock() {
      if let Some(app_handle) = app_handle_opt.as_ref() {
        let app_clone = app_handle.clone();
        
        // å¼‚æ­¥æ‰§è¡Œæˆªå›¾
        tauri::async_runtime::spawn(async move {
          match capture_full_screen().await {
            Ok(screenshot_data) => {
              // å‘é€æˆªå›¾æ•°æ®åˆ°å‰ç«¯
              let event_data = serde_json::json!({
                "success": true,
                "imageData": screenshot_data.base64_data,
                "width": screenshot_data.width,
                "height": screenshot_data.height
              });
              
              if let Err(e) = app_clone.emit("screenshot-captured", event_data) {
                println!("âŒ Failed to emit screenshot event: {}", e);
              } else {
                println!("âœ… Screenshot captured and sent to frontend");
              }
            }
            Err(e) => {
              println!("âŒ Screenshot failed: {}", e);
              let error_data = serde_json::json!({
                "success": false,
                "error": e
              });
              let _ = app_clone.emit("screenshot-captured", error_data);
            }
          }
        });
      }
    }
  }
  
  Ok(())
}

#[derive(Debug)]
struct ScreenshotData {
  base64_data: String,
  width: u32,
  height: u32,
}

async fn capture_full_screen() -> Result<ScreenshotData, String> {
  println!("ğŸ“¸ Capturing full screen...");
  
  // è·å–ä¸»æ˜¾ç¤ºå™¨
  let monitors = Monitor::all().map_err(|e| format!("Failed to get monitors: {}", e))?;
  let primary_monitor = monitors.into_iter().next().ok_or("No monitor found")?;
  
  println!("ğŸ–¥ï¸ Monitor info: {}x{}", primary_monitor.width(), primary_monitor.height());
  
  // æˆªå–å±å¹•
  let image = primary_monitor.capture_image().map_err(|e| format!("Failed to capture screen: {}", e))?;
  
  // è½¬æ¢ä¸ºPNGå­—èŠ‚æ•°æ®
  let mut png_data = Vec::new();
  {
    use std::io::Cursor;
    let mut cursor = Cursor::new(&mut png_data);
    image.write_to(&mut cursor, ImageFormat::Png)
      .map_err(|e| format!("Failed to encode PNG: {}", e))?;
  }
  
  // è½¬æ¢ä¸ºbase64
  let base64_data = general_purpose::STANDARD.encode(&png_data);
  
  println!("âœ… Screenshot captured: {}x{}, size: {} bytes", 
           image.width(), image.height(), png_data.len());
  
  Ok(ScreenshotData {
    base64_data,
    width: image.width(),
    height: image.height(),
  })
}

#[tauri::command]
async fn save_screenshot_area(
  image_data: String,
  x: u32,
  y: u32,
  width: u32,
  height: u32
) -> Result<String, String> {
  println!("ğŸ’¾ Saving screenshot area: x={}, y={}, width={}, height={}", x, y, width, height);
  
  // è§£ç base64å›¾ç‰‡æ•°æ®
  let image_bytes = general_purpose::STANDARD
    .decode(&image_data)
    .map_err(|e| format!("Failed to decode base64: {}", e))?;
  
  // åŠ è½½å›¾ç‰‡
  let img = image::load_from_memory(&image_bytes)
    .map_err(|e| format!("Failed to load image: {}", e))?;
  
  // è£å‰ªå›¾ç‰‡
  let cropped = img.crop_imm(x, y, width, height);
  
  // è½¬æ¢ä¸ºPNGå­—èŠ‚æ•°ç»„
  let mut output = Vec::new();
  {
    use std::io::Cursor;
    let mut cursor = Cursor::new(&mut output);
    cropped.write_to(&mut cursor, ImageFormat::Png)
      .map_err(|e| format!("Failed to write PNG: {}", e))?;
  }
  
  // è½¬æ¢ä¸ºbase64
  let base64_result = general_purpose::STANDARD.encode(&output);
  
  println!("âœ… Screenshot area saved, size: {} bytes", output.len());
  Ok(base64_result)
}

#[tauri::command]
async fn simulate_text_input(text: String) -> Result<(), String> {
  println!("ğŸ”¤ Starting text input simulation: {}", text);
  
  // çŸ­æš‚å»¶è¿Ÿç¡®ä¿çª—å£éšè—å®Œæˆ
  tokio::time::sleep(std::time::Duration::from_millis(500)).await;
  
  // è·å–è®°å½•çš„å…‰æ ‡ä½ç½®
  let cursor_pos = CURSOR_POSITION.get_or_init(|| Arc::new(Mutex::new(None)));
  let saved_position = if let Ok(pos) = cursor_pos.lock() {
    *pos
  } else {
    None
  };
  
  // å¦‚æœæœ‰ä¿å­˜çš„å…‰æ ‡ä½ç½®ï¼Œå…ˆè®¾ç½®åˆ°è¯¥ä½ç½®å¹¶ç‚¹å‡»
  if let Some((x, y)) = saved_position {
    println!("ğŸ¯ Moving cursor to saved position: ({}, {})", x, y);
    if let Err(e) = set_cursor_position(x, y) {
      println!("âš ï¸ Failed to set cursor position: {}", e);
    }
    
    // ç‚¹å‡»ä¸€ä¸‹ç¡®ä¿ç„¦ç‚¹å’Œæ¿€æ´»æ–‡æœ¬è¾“å…¥ä½ç½®
    println!("ğŸ–±ï¸ Clicking at cursor position to activate");
    if let Err(e) = click_at_position(x, y) {
      println!("âš ï¸ Failed to click at position: {}", e);
    }
    
    // ç­‰å¾…ç‚¹å‡»ç”Ÿæ•ˆ
    tokio::time::sleep(std::time::Duration::from_millis(200)).await;
  } else {
    println!("âš ï¸ No saved cursor position found");
  }
  
  let mut enigo = Enigo::new(&Settings::default()).map_err(|e| e.to_string())?;
  
  // é€å­—ç¬¦è¾“å…¥ï¼Œæ”¯æŒä¸­æ–‡
  for char in text.chars() {
    if char == '\n' {
      enigo.key(Key::Return, enigo::Direction::Click).map_err(|e| e.to_string())?;
    } else {
      enigo.text(&char.to_string()).map_err(|e| e.to_string())?;
    }
    // çŸ­æš‚å»¶è¿Ÿæ¨¡æ‹Ÿè‡ªç„¶æ‰“å­—
    tokio::time::sleep(std::time::Duration::from_millis(30)).await;
  }
  
  println!("âœ… Text input simulation completed");
  Ok(())
}

#[tauri::command]
async fn show_quick_input_window(app: tauri::AppHandle) -> Result<(), String> {
  println!("ğŸ” show_quick_input_window called");
  
  // è·å–ä¿å­˜çš„é¼ æ ‡ä½ç½®
  let cursor_pos = CURSOR_POSITION.get_or_init(|| Arc::new(Mutex::new(None)));
  let saved_position = if let Ok(pos) = cursor_pos.lock() {
    *pos
  } else {
    None
  };
  
  if let Some(window) = app.get_webview_window("quick-input") {
    println!("âœ… Found existing quick-input window, showing it");
    
    // å¦‚æœæœ‰é¼ æ ‡ä½ç½®ï¼Œè®¡ç®—æ™ºèƒ½å®šä½
    if let Some((mouse_x, mouse_y)) = saved_position {
      if let Ok(position) = calculate_smart_position(mouse_x, mouse_y, 740, 100) {
        println!("ğŸ“ Setting window position to: ({}, {})", position.0, position.1);
        if let Err(e) = window.set_position(tauri::Position::Physical(tauri::PhysicalPosition { x: position.0, y: position.1 })) {
          println!("âš ï¸ Failed to set window position: {}", e);
        }
      }
    }
    
    match window.show() {
      Ok(_) => println!("âœ… Existing window.show() successful"),
      Err(e) => {
        println!("âŒ Existing window.show() failed: {}", e);
        return Err(e.to_string());
      }
    }
    match window.set_focus() {
      Ok(_) => println!("âœ… Existing window.set_focus() successful"),
      Err(e) => {
        println!("âŒ Existing window.set_focus() failed: {}", e);
        return Err(e.to_string());
      }
    }
  } else {
    println!("ğŸ”¨ Creating new quick-input window");
    println!("ğŸ“ Window URL: quick-input.html");
    println!("ğŸ“ Window size: 740x100, transparent: true, always_on_top: true");
    
    // å¦‚æœçª—å£ä¸å­˜åœ¨ï¼Œåˆ›å»ºæ–°çª—å£
    let mut window_builder = tauri::WebviewWindowBuilder::new(
      &app,
      "quick-input",
      tauri::WebviewUrl::App("quick-input.html".into())
    )
    .title("Yao Quick Input")
    .inner_size(740.0, 100.0)
    .resizable(false)
    .decorations(false)
    .transparent(true)
    .always_on_top(true)
    .skip_taskbar(true);
    
    // å¦‚æœæœ‰é¼ æ ‡ä½ç½®ï¼Œä½¿ç”¨æ™ºèƒ½å®šä½ï¼Œå¦åˆ™å±…ä¸­
    if let Some((mouse_x, mouse_y)) = saved_position {
      if let Ok(position) = calculate_smart_position(mouse_x, mouse_y, 740, 100) {
        println!("ğŸ“ Creating window at smart position: ({}, {})", position.0, position.1);
        window_builder = window_builder.position(position.0 as f64, position.1 as f64);
      } else {
        window_builder = window_builder.center();
      }
    } else {
      window_builder = window_builder.center();
    }
    
    let window = window_builder.build()
    .map_err(|e| {
      println!("âŒ Failed to create quick-input window: {}", e);
      e.to_string()
    })?;
    
    println!("âœ… Quick-input window created successfully");
    
    match window.show() {
      Ok(_) => println!("âœ… New window.show() successful"),
      Err(e) => {
        println!("âŒ New window.show() failed: {}", e);
        return Err(e.to_string());
      }
    }
    
    match window.set_focus() {
      Ok(_) => println!("âœ… New window.set_focus() successful"),
      Err(e) => {
        println!("âŒ New window.set_focus() failed: {}", e);
        return Err(e.to_string());
      }
    }
  }
  
  println!("ğŸ‰ show_quick_input_window completed successfully");
  Ok(())
}

#[tauri::command]
async fn register_global_shortcut(_app: tauri::AppHandle) -> Result<(), String> {
  // å…¨å±€å¿«æ·é”®å·²åœ¨ setup ä¸­æ³¨å†Œï¼Œè¿™ä¸ªå‘½ä»¤ä¸»è¦ç”¨äºå‰ç«¯ç¡®è®¤æ³¨å†ŒçŠ¶æ€
  Ok(())
}

#[tauri::command]
async fn show_main_window(app: tauri::AppHandle) -> Result<(), String> {
  if let Some(window) = app.get_webview_window("main") {
    window.show().map_err(|e| e.to_string())?;
    window.set_focus().map_err(|e| e.to_string())?;
    window.unminimize().map_err(|e| e.to_string())?;
  }
  Ok(())
}

#[tauri::command]
async fn hide_main_window(app: tauri::AppHandle) -> Result<(), String> {
  if let Some(window) = app.get_webview_window("main") {
    window.hide().map_err(|e| e.to_string())?;
  }
  Ok(())
}

fn setup_system_tray(app: &tauri::App) -> Result<(), Box<dyn std::error::Error>> {
  let show_item = MenuItem::with_id(app, "show", "æ˜¾ç¤ºä¸»çª—å£", true, None::<&str>)?;
  let hide_item = MenuItem::with_id(app, "hide", "éšè—åˆ°æ‰˜ç›˜", true, None::<&str>)?;
  let quit_item = MenuItem::with_id(app, "quit", "é€€å‡º", true, None::<&str>)?;
  let menu = Menu::with_items(app, &[&show_item, &hide_item, &quit_item])?;

  let _tray = TrayIconBuilder::with_id("main-tray")
    .menu(&menu)
    .tooltip("Yao - AIèŠå¤©åŠ©æ‰‹")
    .icon(app.default_window_icon().unwrap().clone())
    .on_menu_event(move |app, event| {
      match event.id.as_ref() {
        "show" => {
          if let Some(window) = app.get_webview_window("main") {
            let _ = window.show();
            let _ = window.set_focus();
            let _ = window.unminimize();
          }
        }
        "hide" => {
          if let Some(window) = app.get_webview_window("main") {
            let _ = window.hide();
          }
        }
        "quit" => {
          app.exit(0);
        }
        _ => {}
      }
    })
    .on_tray_icon_event(|tray, event| {
      if let tauri::tray::TrayIconEvent::Click {
        button: tauri::tray::MouseButton::Left,
        button_state: tauri::tray::MouseButtonState::Up,
        ..
      } = event {
        let app = tray.app_handle();
        if let Some(window) = app.get_webview_window("main") {
          if window.is_visible().unwrap_or(false) {
            let _ = window.hide();
          } else {
            let _ = window.show();
            let _ = window.set_focus();
            let _ = window.unminimize();
          }
        }
      }
    })
    .build(app)?;

  Ok(())
}

#[tokio::main]
async fn main() {
  tauri::Builder::default()
    .plugin(tauri_plugin_store::Builder::new().build())
    .plugin(tauri_plugin_process::init())
    .plugin(tauri_plugin_shell::init())
    .plugin(tauri_plugin_fs::init())
    .plugin(tauri_plugin_global_shortcut::Builder::new().build())
    .setup(|app| {
      println!("ğŸš€ Setting up application...");
      
      // å­˜å‚¨åº”ç”¨å¥æŸ„ä¾›é¼ æ ‡é’©å­ä½¿ç”¨
      let app_handle = app.handle().clone();
      let app_handle_storage = APP_HANDLE.get_or_init(|| Arc::new(Mutex::new(None)));
      if let Ok(mut handle) = app_handle_storage.lock() {
        *handle = Some(app_handle);
      }
      
      // è®¾ç½®å…¨å±€é¼ æ ‡é’©å­ (Ctrl+é¼ æ ‡å·¦é”®)
      println!("ğŸ–±ï¸ Setting up global mouse hook for Ctrl+Left Click...");
      match setup_mouse_hook() {
        Ok(_) => println!("âœ… Global mouse hook set up successfully"),
        Err(e) => {
          println!("âš ï¸ Failed to set up mouse hook: {}", e);
          println!("âš ï¸ Ctrl+Left Click functionality will not be available");
        }
      }

      // è®¾ç½®å…¨å±€æˆªå›¾å¿«æ·é”® (Ctrl+Alt+A)
      println!("âŒ¨ï¸ Setting up global screenshot shortcut...");
      let app_handle_for_shortcut = app.handle().clone();
      if let Err(e) = app.global_shortcut().register("Ctrl+Alt+A") {
        println!("âš ï¸ Failed to register screenshot shortcut: {}", e);
      } else {
        println!("âœ… Screenshot shortcut (Ctrl+Alt+A) registered successfully");
        
        // ç›‘å¬å¿«æ·é”®äº‹ä»¶
        let app_clone = app_handle_for_shortcut.clone();
        let _ = app.global_shortcut().on_shortcut("Ctrl+Alt+A", move |_, _, _| {
          println!("ğŸ“¸ Screenshot shortcut triggered!");
          let app_inner = app_clone.clone();
          tauri::async_runtime::spawn(async move {
            // å‘é€å¿«æ·é”®äº‹ä»¶åˆ°å‰ç«¯
            if let Err(e) = app_inner.emit("shortcut", "Ctrl+Alt+A") {
              println!("âŒ Failed to emit shortcut event: {}", e);
            }
          });
        });
      }
      
      // è®¾ç½®ç³»ç»Ÿæ‰˜ç›˜
      println!("ğŸ–¥ï¸ Setting up system tray...");
      setup_system_tray(&app)?;
      
      println!("ğŸ‰ Application setup completed successfully");
      Ok(())
    })
    .invoke_handler(tauri::generate_handler![
      proxy_models,
      proxy_chat_stream,
      proxy_chat,
      get_log_path,
      write_log_line,
      get_config_path,
      get_conversations_path,
      start_chat_stream,
      simulate_text_input,
      show_quick_input_window,
      register_global_shortcut,
      show_main_window,
      hide_main_window,
      start_screenshot,
      save_screenshot_area
    ])
    .run(tauri::generate_context!())
    .expect("error while running tauri application");
}